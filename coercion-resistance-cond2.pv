(* Verification of Condition 2 in the definition of coercion-resistance  *)


(* Equational theory for cryptography + autogenerated ZK-theory *)

fun public1/1.
fun blindsign/2.
fun false/0.
fun sigver/3.
fun fakezk1/3. (* autogenerated ZK-theory *)
fun sk/1.
fun fakezk0/2. (* autogenerated ZK-theory *)
fun beta1/0. (* autogenerated ZK-theory *)
fun hash/1.
fun blindmessage/1.
fun or/2.
fun sign/2.
fun fakever/3. (* autogenerated ZK-theory *)
fun pk/1.
fun fakepublic/2. (* autogenerated ZK-theory *)
fun land/2.
fun alpha1/0. (* autogenerated ZK-theory *)
fun zkver0/1. 
fun zk0/2.
fun penc/3.
fun g/2. (* autogenerated ZK-theory *)
fun blindver/3.
fun true/0.
fun message/1.
fun unblind/2.
fun blind/2.
fun formula/1. (* autogenerated ZK-theory *)
fun eq/2.
reduc dec(penc(x,pk(y),z),sk(y)) = x.
reduc pet(penc(x,pk(y),z1),penc(x,pk(y),z2),sk(y)) = true.
reduc equals(x,x)=x.
equation eq(x,x) = true.
equation message(sign(x,y)) = x.
equation sigver(sign(x,sk(y)),x,pk(y)) = true.
equation blindver(unblind(blindsign(blind(x,z),sk(y)),z),x,pk(y)) = true.
equation blindmessage(unblind(blindsign(blind(x,z),y),z)) = x.

equation public1(zk0(xalpha1x0,xbeta1x1)) = xbeta1x1. (* autogenerated ZK-theory for ZK(1;1;true) *)
equation formula(zk0(xalpha1x0,xbeta1x1)) = true. (* autogenerated ZK-theory for ZK(1;1;true) *)
equation public1(fakezk1(x3,xbeta1x1,y4)) = xbeta1x1. (* autogenerated ZK-theory *)
equation formula(fakezk0(x3,y4)) = y4. (* autogenerated ZK-theory *)
equation formula(fakezk1(x3,xbeta1x1,y4)) = y4. (* autogenerated ZK-theory *)
equation zkver0(zk0((index,r3,cred,r2,vote,r1),(penc(vote,pk(y),r1),penc(cred,pk(y),r2),penc(index,pk(y),r3),pk(y),vote,z1,z2,z3))) = true. (* replaced by AlternativeZKVer for zk type ZK(1;1;true) *)
equation zkver0(zk0((index,r3,cred,r2,vote,r1),(penc(vote,pk(y),r1),penc(cred,pk(y),r2),penc(index,pk(y),r3),pk(y),z1,vote,z2,z3))) = true. (* replaced by AlternativeZKVer for zk type ZK(1;1;true) *)
equation zkver0(zk0((index,r3,cred,r2,vote,r1),(penc(vote,pk(y),r1),penc(cred,pk(y),r2),penc(index,pk(y),r3),pk(y),z1,z2,vote,z3))) = true. (* replaced by AlternativeZKVer for zk type ZK(1;1;true) *)
equation zkver0(zk0((index,r3,cred,r2,vote,r1),(penc(vote,pk(y),r1),penc(cred,pk(y),r2),penc(index,pk(y),r3),pk(y),z1,z2,z3,vote))) = true. (* replaced by AlternativeZKVer for zk type ZK(1;1;true) *)


(* private channels *)

private free chvote,chTE,chVE,internal1,chvotea,internal.

(* message tags *)

free n1,n2.

(* public channels *)

free res,comm,c.

(* votes *)

free va,vb,vc.

(* Non-deterministic choice of the vote *)

let votechooser = 
    ((out(chvote,va)) | (((out(chvote,vb)) | (out(chvote,vc))))).

(* Variant of the previous process for vote va *)

let votechoosera = 
    out(chvotea,va).

(* Identity issuer *)

let issuer = 
    new id;
    out(comm,id); 
    out(chRI,id)| 
    out(chVI,id).

(* Registration for voter j *)

let voterreg = 
    new nonce1;

(* Due to overapproximation, ProVerif does not tell replicated from non-replicated processes.  This nonce handshake with the registrar guarantees that each  instance of voterreg receives a different credential. This is not required in the original applied pi-calculus specification since voterreg is not replicated. The reasoning is similar for the other nonce handshakes in the protocol specification. *)                              
    
    out(chVR2,(n1,nonce1)); 
    in(chVR2,(=n2,=nonce1,index,index1,index2,cred,cred1,cred2)); 
    out(internal1,(n2,index,index1,index2,cred,cred1,cred2)).

(* Registration for voter i *)

let coercedvoter = 
    in(chVI,id);
    new nonce;
    out(chVR1,(n1,nonce)); 
    in(chVR1,(=n2,=nonce,index,index1,index2,cred,cred1,cred2)); 
    new fakeindex;
    new fakecred; 
    out(c,(choice[index,fakeindex],choice[cred,fakecred]));
    out(internal,(n2,index,index1,index2,fakeindex,cred,cred1,cred2,fakecred)).

(* Voting phase for  j (left-hand side) and i (right-hand side) *)


let votercast = 
    in(internal,(=n2,index,index1,index2,fakeindex,cred,cred1,cred2,fakecred)); 
    in(internal1,(=n2,=index,=index1,=index2,=cred,=cred1,=cred2));
    in(chvotea,vote); 
    out(chVE,(choice[(index,index,index1,index2),(fakeindex,index,index1,index2)],choice[(cred,cred,cred1,cred2),(fakecred,cred,cred1,cred2)]));
    new r1; 
    new r2; 
    new r3;
    out(comm,zk0((choice[index1,index],r3,choice[cred1,cred],r2,vote,r1),(penc(vote,pk(kT),r1),penc(choice[cred1,cred],pk(kT),r2),penc(choice[index1,index],pk(kT),r3),pk(kT),va,vb,vc))).

(* Corrupted voters *)

let corruptedvoter = 
    in(chVI,id);
    new nonce;  
    out(chVR,(n1,nonce));
    in(chVR,(=n2,=nonce,index,cred)); 
    out(comm,(index,cred)).

(* Regular voters *)

let voter = 
    in(chVI,id);
    new nonce; 
    new r1; 
    new r2; 
    new r3;
    out(chVR,(n1,nonce)); 
    in(chVR,(=n2,=nonce,index,cred)); 
    in(chvote,vote); 
    out(comm,zk0((index,r3,cred,r2,vote,r1),(penc(vote,pk(kT),r1),penc(cred,pk(kT),r2),penc(index,pk(kT),r3),pk(kT),va,vb,vc))).

(* Registrar *)

let registrar = 
    in(chRI,id);
    in(chVR,(=n1,nonceV)); 
    in(chRT,(=n1,nonceT)); 
    new nonce;
    new index;
    new cred; 
    new r; 
    let encindex = penc(index,pk(kT),r) in
    let enccred = penc(cred,pk(kT),r) in 
    (out(comm,(sign(encindex,sk(kR)),sign(enccred,sk(kR)))) | 
    (out(chRT,(n2,nonceT,encindex,enccred)) | 
    (out(chVR,(n2,nonceV,index,cred))))).

(* Tallying authority *)

let tallier = 
    new nonce; 
    out(chRT,(n1,nonce)); 
    in(chRT,(=n2,=nonce,encindex1,enccred1)); 
    in(comm,zkp); 
    let xif13 = equals(zkver0(zkp),true) in 
    let (encvote,encindex,enccred,=pk(kT),=va,=vb,=vc)=public1(zkp) in 
    let x = pet(encindex,encindex1,sk(kT)) in
    let y = pet(enccred,enccred1,sk(kT)) in 
    let vote = dec(encvote,sk(kT)) in 
    out(res,vote).

(* Extractor *)

let extractor = 
    in(chVI,id);
    new nonceE; 
    out(chVR3,(n1,nonceE)); 
    in(chVR3,(=n2,=nonceE,indexi,indexj,indexE,credi,credj,credE)); 
    in(chVE,(coercedindex,=indexi,=indexj,=indexE,coercercred,=credi,=credj,=credE)); 
    ! in(chTE,(=n1,encindex,encindex1,enccred,enccred1,encvote)); 
    let vote = dec(encvote,sk(kT)) in 
    let index = dec(encindex,sk(kT)) in
    let index1 = dec(encindex1,sk(kT)) in
    let cred = dec(enccred,sk(kT)) in 
    let cred1 = dec(enccred1,sk(kT)) in 
    let xif8 = equals((index,index1,cred,cred1),(coercedindex,choice[indexi,indexE],coercercred,choice[credi,credE])) in 
    out(res,vote) 
    else 
    let xif7 = equals((index,index1,cred,cred1),(choice[indexj,indexi],choice[indexj,indexi],choice[credj,credi],choice[credj,credi])) in 
    out(res,vote).

(* Instance of the tallying authority for voter i, voter j, and extractor k *)

let ctallier = 
    new nonce; 
    out(chcRT,(n1,nonce)); 
    in(chcRT,(=n2,=nonce,encindex1,enccred1)); 
    in(comm,zkp); 
    let xif9 = equals(zkver0(zkp),true) in 
    let (encvote,encindex,enccred,=pk(kT),=va,=vb,=vc) = public1(zkp) in 
    out(chTE,(n1,encindex,encindex1,enccred,enccred1,encvote)).

(*  Instance of the registrar for the credentials of voters i,j, and k *)

let cregistrar = 
    in(chRI,id);
    in(chcRT,(=n1,nonceT)); 
    in(chcRT,(=n1,nonceT2)); 
    in(chcRT,(=n1,nonceT3)); 
    in(chVR1,(=n1,nonceV)); 
    in(chVR2,(=n1,nonceV2)); 
    in(chVR3,(=n1,nonceE)); 
    new index;
    new cred; 
    new r; 
    new index2;
    new cred2; 
    new r2; 
    new index3;
    new cred3; 
    new r3; 
    let encindex = penc(index,pk(kT),r) in
    let enccred = penc(cred,pk(kT),r) in 
    let encindex2 = penc(index2,pk(kT),r2) in
    let enccred2 = penc(cred2,pk(kT),r2) in 
    let encindex3 = penc(cred3,pk(kT),r3) in
    let enccred3 = penc(cred3,pk(kT),r3) in 
    out(chcRT,(n2,nonceT,choice[encindex,encindex3],choice[enccred,enccred3])); 
    out(chcRT,(n2,nonceT2,choice[encindex2,encindex],choice[enccred2,enccred])); 
    out(chcRT,(n2,nonceT3,choice[encindex3,encindex2],choice[enccred3,enccred2])); 
    out(chVR1,(n2,nonceV,index,index2,index3,cred,cred2,cred3)); 
    out(chVR2,(n2,nonceV2,index,index2,index3,cred,cred2,cred3)); 
    out(chVR3,(n2,nonceE,index,index2,index3,cred,cred2,cred3)); 
    (out(comm,(sign(encindex,sk(kR)),sign(enccred,sk(kR)))) | 
    out(comm,(sign(encindex2,sk(kR)),sign(enccred2,sk(kR)))) | 
    out(comm,(sign(encindex3,sk(kR)),sign(enccred3,sk(kR))))).

let sanityProcess = 
    if true=true then 0 else event SANITYFAILED().

process 
	new kT; 
	new kR; 
	new chVR;	
	new chVR1; 
	new chVR2; 
	new chVR3; 
	new chVI;
	new chRI;
	new chcRT; 
	new chRT; 
	out(comm,(pk(kT),pk(kR))); 
	! ctallier | 
	! tallier | 
	! voter | 
	votercast | 
	voterreg | 
	coercedvoter | 
	! corruptedvoter | 
	cregistrar | 
	! registrar | 
	! votechooser | 
	! votechoosera | 
	extractor |
	! issuer 
