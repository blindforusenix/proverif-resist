(* Verification of Condition 2 in the definition of coercion-resistance  *)



(* Equational theory for cryptography + autogenerated ZK-theory *)

fun public1/1.
fun blindsign/2.
fun false/0.
fun sigver/3.
fun fakezk1/3. (* autogenerated ZK-theory *)
fun sk/1.
fun fakezk0/2. (* autogenerated ZK-theory *)
fun beta1/0. (* autogenerated ZK-theory *)
fun hash/1.
fun blindmessage/1.
fun or/2.
fun sign/2.
fun fakever/3. (* autogenerated ZK-theory *)
fun pk/1.
fun fakepublic/2. (* autogenerated ZK-theory *)
fun land/2.
fun alpha1/0. (* autogenerated ZK-theory *)
fun zkver0/1. 
fun zk0/2.
fun penc/3.
fun g/2. (* autogenerated ZK-theory *)
fun blindver/3.
fun true/0.
fun message/1.
fun unblind/2.
fun blind/2.
fun formula/1. (* autogenerated ZK-theory *)
fun eq/2.
reduc dec(penc(x,pk(y),z),sk(y)) = x.
reduc pet(penc(x,pk(y),z1),penc(x,pk(y),z2),sk(y)) = true.
reduc equals(x,x)=x.
equation eq(x,x) = true.
equation message(sign(x,y)) = x.
equation sigver(sign(x,sk(y)),x,pk(y)) = true.
equation blindver(unblind(blindsign(blind(x,z),sk(y)),z),x,pk(y)) = true.
equation blindmessage(unblind(blindsign(blind(x,z),y),z)) = x.

equation public1(zk0(xalpha1x0,xbeta1x1)) = xbeta1x1. (* autogenerated ZK-theory for ZK(1;1;true) *)
equation formula(zk0(xalpha1x0,xbeta1x1)) = true. (* autogenerated ZK-theory for ZK(1;1;true) *)
equation public1(fakezk1(x3,xbeta1x1,y4)) = xbeta1x1. (* autogenerated ZK-theory *)
equation formula(fakezk0(x3,y4)) = y4. (* autogenerated ZK-theory *)
equation formula(fakezk1(x3,xbeta1x1,y4)) = y4. (* autogenerated ZK-theory *)
equation zkver0(zk0((index,r3,cred,r2,vote,r1),(penc(vote,pk(y),r1),penc(cred,pk(y),r2),penc(index,pk(y),r3),pk(y),vote,z1,z2,z3))) = true. (* replaced by AlternativeZKVer for zk type ZK(1;1;true) *)
equation zkver0(zk0((index,r3,cred,r2,vote,r1),(penc(vote,pk(y),r1),penc(cred,pk(y),r2),penc(index,pk(y),r3),pk(y),z1,vote,z2,z3))) = true. (* replaced by AlternativeZKVer for zk type ZK(1;1;true) *)
equation zkver0(zk0((index,r3,cred,r2,vote,r1),(penc(vote,pk(y),r1),penc(cred,pk(y),r2),penc(index,pk(y),r3),pk(y),z1,z2,vote,z3))) = true. (* replaced by AlternativeZKVer for zk type ZK(1;1;true) *)
equation zkver0(zk0((index,r3,cred,r2,vote,r1),(penc(vote,pk(y),r1),penc(cred,pk(y),r2),penc(index,pk(y),r3),pk(y),z1,z2,z3,vote))) = true. (* replaced by AlternativeZKVer for zk type ZK(1;1;true) *)


(* private channels *)

private free chvote,chTE,chVE,internal1,chvotea,internal.

(* message tags *)

free n1,n2.

(* public channels *)

free res,comm.

(* votes *)

free va,vb,vc.

(* Non-deterministic choice of the vote *)

let votechooser = 
    ((out(chvote,va)) | (((out(chvote,vb)) | (out(chvote,vc))))).

(* Variant of the previous process for vote va *)

let votechoosera = 
    out(chvotea,va).



(* Voter casting a vote with valid/invalid credential *)

let voterchoice = 
    new nonce; 
    new r1; 
    new r2; 
    new r3;
    out(chVR,(n1,nonce)); 
    in(chVR,(=n2,=nonce,index,cred)); 
    new fakeindex;
    new fakecred;
    in(chvote,vote); 
    out(comm,zk0((choice[index,fakeindex],choice[cred,fakecred],r2,vote,r1),(penc(vote,pk(kT),r1),penc(choice[cred,fakecred],pk(kT),r2),penc(choice[index,fakeindex],pk(kT),r3),pk(kT),va,vb,vc))).



(* Corrupted voters *)

let corruptedvoter = 
    new nonce; 
    out(chVR,(n1,nonce)); 
    in(chVR,(=n2,=nonce,index,cred)); 
    out(comm,(index,cred)).

(* Regular voters *)

let voter = 
    new nonce; 
    new r1; 
    new r2; 
    new r3;
    out(chVR,(n1,nonce)); 
    in(chVR,(=n2,=nonce,index,cred)); 
    in(chvote,vote); 
    out(comm,zk0((index,r3,cred,r2,vote,r1),(penc(vote,pk(kT),r1),penc(cred,pk(kT),r2),penc(index,pk(kT),r3),pk(kT),va,vb,vc))).

(* Registrar *)

let registrar = 
    in(chVR,(=n1,nonceV)); 
    in(chRT,(=n1,nonceT));
    new index; 
    new cred; 
    new r; 
    let encindex = penc(index,pk(kT),r) in 
    let enccred = penc(cred,pk(kT),r) in 
    (out(comm,(sign(encindex,sk(kR)),sign(enccred,sk(kR)))) | 
    (out(chRT,(nonceT,encindex,enccred)) | 
    (out(chVR,(n2,nonceV,index,cred))))).

(* Tallying authority *)

let tallier = 
    new nonce; 
    out(chRT,(n1,nonce)); 
    in(chRT,(=nonce,encindex1,enccred1)). 
    (* the output on channel res is hidden *)


let sanityProcess = 
    if true=true then 0 else event SANITYFAILED().

process 
	new kT; 
	new kR; 
	new chVR;	
	new chVR1; 
	new chVR2; 
	new chVR3; 
	new chcRT; 
	new chRT; 
	out(comm,(pk(kT),pk(kR))); 
	! tallier | 
	! voter | 
	voterchoice | 
	! corruptedvoter | 
	! registrar | 
	! votechooser 
