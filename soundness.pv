(* Verification of Condition 2 in the definition of coercion-resistance  *)


(* Equational theory for cryptography + autogenerated ZK-theory *)

fun public1/1.
fun blindsign/2.
fun false/0.
fun sigver/3.
fun fakezk1/3. (* autogenerated ZK-theory *)
fun sk/1.
fun fakezk0/2. (* autogenerated ZK-theory *)
fun beta1/0. (* autogenerated ZK-theory *)
fun hash/1.
fun blindmessage/1.
fun or/2.
fun sign/2.
fun fakever/3. (* autogenerated ZK-theory *)
fun pk/1.
fun fakepublic/2. (* autogenerated ZK-theory *)
fun land/2.
fun alpha1/0. (* autogenerated ZK-theory *)
fun zkver0/1. 
fun zk0/2.
fun penc/3.
fun g/2. (* autogenerated ZK-theory *)
fun blindver/3.
fun true/0.
fun message/1.
fun unblind/2.
fun blind/2.
fun formula/1. (* autogenerated ZK-theory *)
fun eq/2.
reduc dec(penc(x,pk(y),z),sk(y)) = x.
reduc pet(penc(x,pk(y),z1),penc(x,pk(y),z2),sk(y)) = true.
reduc equals(x,x)=x.
equation eq(x,x) = true.
equation message(sign(x,y)) = x.
equation sigver(sign(x,sk(y)),x,pk(y)) = true.
equation blindver(unblind(blindsign(blind(x,z),sk(y)),z),x,pk(y)) = true.
equation blindmessage(unblind(blindsign(blind(x,z),y),z)) = x.

equation public1(zk0(xalpha1x0,xbeta1x1)) = xbeta1x1. (* autogenerated ZK-theory for ZK(1;1;true) *)
equation formula(zk0(xalpha1x0,xbeta1x1)) = true. (* autogenerated ZK-theory for ZK(1;1;true) *)
equation public1(fakezk1(x3,xbeta1x1,y4)) = xbeta1x1. (* autogenerated ZK-theory *)
equation formula(fakezk0(x3,y4)) = y4. (* autogenerated ZK-theory *)
equation formula(fakezk1(x3,xbeta1x1,y4)) = y4. (* autogenerated ZK-theory *)
equation zkver0(zk0((index,r3,cred,r2,vote,r1),(penc(vote,pk(y),r1),penc(cred,pk(y),r2),penc(index,pk(y),r3),pk(y),vote,z1,z2,z3))) = true. (* replaced by AlternativeZKVer for zk type ZK(1;1;true) *)
equation zkver0(zk0((index,r3,cred,r2,vote,r1),(penc(vote,pk(y),r1),penc(cred,pk(y),r2),penc(index,pk(y),r3),pk(y),z1,vote,z2,z3))) = true. (* replaced by AlternativeZKVer for zk type ZK(1;1;true) *)
equation zkver0(zk0((index,r3,cred,r2,vote,r1),(penc(vote,pk(y),r1),penc(cred,pk(y),r2),penc(index,pk(y),r3),pk(y),z1,z2,vote,z3))) = true. (* replaced by AlternativeZKVer for zk type ZK(1;1;true) *)
equation zkver0(zk0((index,r3,cred,r2,vote,r1),(penc(vote,pk(y),r1),penc(cred,pk(y),r2),penc(index,pk(y),r3),pk(y),z1,z2,z3,vote))) = true. (* replaced by AlternativeZKVer for zk type ZK(1;1;true) *)


(* private channels *)

private free chvote,chTE,chVE,internal1,chvotea,internal.

(* message tags *)

free n1,n2.

(* public channels *)

free res,comm.

(* votes *)

free va,vb,vc.

(* Query for Soundness *)


query evinj:ENDVOTE(x) ==> ((evinj:BEGINVOTE(x,y) ==> evinj: STARTID(y)) | evinj:STARTCORID(z)). 



(* Non-deterministic choice of the vote *)

let votechooser = 
    ((out(chvote,va)) | (((out(chvote,vb)) | (out(chvote,vc))))).


(* Tallying authority *)

let tallier = 
    new nonce; 
    out(chRT,(n1,nonce)); 
    in(chRT,(=n2,=nonce,encindex1,enccred1)); 
    in(comm,zkp); 
    let xif13 = equals(zkver0(zkp),true) in 
    let (encvote,encindex,enccred,=pk(kT),=va,=vb,=vc)=public1(zkp) in 
    let x = pet(encindex,encindex1,sk(kT)) in
    let y = pet(enccred,enccred1,sk(kT)) in 
    let vote = dec(encvote,sk(kT)) in 
    out(res,vote);
    event ENDVOTE(vote).

(* Identity issuer *)

let issuer = 
    in(chVI,(=n1,nonceV));
    in(chRI,(=n1,nonceR));
    new id;
    event NEWID(id);
    out(comm,id);
    out(chVI,(n2,nonceV,id));
    out(chRI,(n2,nonceR,id)).
    

(* Registrar *)

let registrar = 
    in(chVR,(=n1,nonceV)); 
    in(chRT,(=n1,nonceT));
    new nonce;
    out(chRI,(n1,nonce));
    in(chRI,(=n2,=nonce,id)); 
    new index;
    new cred; 
    new r;
    let encindex = penc(index,pk(kT),r) in 
    let enccred = penc(cred,pk(kT),r) in 
    (out(comm,(sign(encindex,sk(kR)),sign(enccred,sk(kR)))) | 
    (out(chRT,(n2,nonceT,encindex,enccred)) | 
    (out(chVR,(n2,nonceV,index,cred))))).

(* Regular voters *)

let voter = 
    new nonce;
    new nonce1; 
    out(chVI,(n1,nonce1));
    out(chVR,(n1,nonce)); 
    in(chVI,(=n2,=nonce1,id));
    event STARTID(id);
    new r1; 
    new r2; 
    in(chVR,(=n2,=nonce,index,cred)); 
    in(chvote,vote); 
    event BEGINVOTE(vote,id);
    out(comm,zk0((index,r3,cred,r2,vote,r1),(penc(vote,pk(kT),r1),penc(cred,pk(kT),r2),penc(index,pk(kT),r3),pk(kT),va,vb,vc))).

(* Corrupted voters *)

let corruptedvoter = 
    new nonce; 
    new nonce1; 
    out(chVI,(n1,nonce1));
    out(chVR,(n1,nonce)); 
    in(chVI,(=n2,=nonce1,id));
    event STARTCORID(id);
    in(chVR,(=n2,=nonce,index,cred)); 
    out(comm,(index,cred)).

let sanityProcess = 
    if true=true then 0 else event SANITYFAILED().

process 
	new kT; 
	new kR; 
	new chVR;	
	new chVI;
	new chRI;
	new chVR1; 
	new chVR2; 
	new chVR3; 
	new chcRT; 
	new chRT; 
	out(comm,(pk(kT),pk(kR))); 
	! issuer |
	! tallier | 
	! voter | 
	! corruptedvoter | 
	! registrar | 
	! votechooser  

